"""
____________ _____ _____ _____ _      ________  ________ _   _ _____ _   _ 
| ___ \ ___ \_   _/  ___|_   _| |    |  ___|  \/  |  _  | | | |_   _| | | |
| |_/ / |_/ / | | \ `--.  | | | |    | |__ | .  . | | | | | | | | | | |_| |
| ___ \    /  | |  `--. \ | | | |    |  __|| |\/| | | | | | | | | | |  _  |
| |_/ / |\ \ _| |_/\__/ / | | | |____| |___| |  | \ \_/ / |_| | | | | | | |
\____/\_| \_|\___/\____/  \_/ \_____/\____/\_|  |_/\___/ \___/  \_/ \_| |_/
"""

import os
import argparse
import sys

import genmsg
import genmsg.gentools
import genmsg.msg_loader
import genmsg.msgs
import genmsg.command_line
from genmsg import InvalidMsgSpec
from genmsg import MsgContext
from genmsg import MsgGenerationException
from genmsg import MsgSpec
from genmsg.base import log

# Primitive types to ROS2 and their matching to CDDL 
ros_types = { 'bool':'bool', 'byte':"uint .size 1", 'char':"tstr .size 1", 'float32':'float32', 'float64':'float64', 'int8':"int .size 1", \
    'uint8':"uint .size 1", 'int16':"int .size 2", 'uint16':"uint .size 2", 'int32':"int .size 4", 'uint32':"uint .size 4", 'int64':"int .size 8", \
    'uint64':"uint .size 8", 'string':"tstr .size 2..64", 'wstring':"tstr .size 2..64"}

builtin_types = {'std_msgs/Header':"Header", 'duration':"Duration", 'time':"Time"}

imported_types = {}
return_values = []
enum_types = []
enum_header = "MSG_"


def parse_args():
    parser = argparse.ArgumentParser(
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    parser.add_argument(
        '-i', '--indir', dest='indir', required=True,
        help='Input Directory'
    )

    parser.add_argument(
        '-o', '--outdir', dest='outdir', required=True,
        help='Output Directory'
    )

    parser.add_argument(
        '-f', '--filename', dest='filename', required=True,
        help='Output File Name'
    )

    parser.add_argument(
        '-p', '--package', dest='package', required=False,
        help='ROS package that generated msg'
    )

    return parser.parse_args()


def main(abs_out_path, abs_outfile, msg_files, package, search_path):
    msg_context = MsgContext.create_default()

    with open(abs_outfile, 'w') as fd:

        fd.write(";\n")
        fd.write("; Autogenerated Bristlemouth CDDL file\n")
        fd.write("; Copyright (c) 2022 Sofar Ocean Technologies\n")
        fd.write(";\n")
        fd.write(";\n\n")

        # Then iterate through the .msg files to import new types
        for f in msg_files:
            skipping = 0 
            try:
                f = os.path.abspath(f)
                infile_name = os.path.basename(f)
                full_type = genmsg.gentools.compute_full_type_name(package, infile_name)

                # CDDL script does not like '/' -- Change types to use "_" instead for delimiter
                cddl_full_type = full_type.replace('/', '_')

                # Extract the content of the .msg file
                spec =  genmsg.msg_loader.load_msg_from_file(msg_context, f, full_type)

                types = list(zip(*spec.fields()))[0]
                values = list(zip(*spec.fields()))[1]

                # If a type includes another custom type that is not currently in list, skip for now
                for t in types:
                    if '[' in t:
                        array_type = t.split('[')[0]
                        if array_type in ros_types.keys() or array_type in imported_types.keys() or array_type in builtin_types.keys():
                            continue
                        else:
                            skipping = 1
                    elif t in ros_types.keys() or t in imported_types.keys() or t in builtin_types.keys():
                        continue
                    else:
                        skipping = 1

                if skipping:
                    # add back to end of file list
                    msg_files.append(f)
                    continue
                
                return_values.append(cddl_full_type)
                enum_types.append(enum_header + cddl_full_type.upper())

                fd.write("; Type: %s\n" % cddl_full_type)
                fd.write("%s = [\n" % cddl_full_type)

                for i in range(len(values)):
                    if '[' in types[i]:
                        bm_type = types[i].split('[')[0]
                        array_size = types[i].split('[')[1].split(']')[0]
                        if bm_type in ros_types.keys():
                            fd.write("\t%s: [0**%s (%s)],\n" % (values[i], array_size, ros_types[bm_type]))
                        elif bm_type in imported_types.keys():
                            fd.write("\t%s: [0**%s (%s)],\n" % (values[i], array_size, imported_types[bm_type]))
                        elif bm_type in builtin_types.keys():
                            fd.write("\t%s: [0**%s (%s_%s)],\n" % (values[i], array_size, package, builtin_types[bm_type]))
                        else:
                            print("we shouldn't get here")
                    elif types[i] in ros_types.keys():
                        fd.write("\t%s: %s,\n" % (values[i], ros_types[types[i]]))
                    elif types[i] in imported_types.keys():
                        fd.write("\t%s: %s,\n" % (values[i], imported_types[types[i]]))
                    elif types[i] in builtin_types.keys():
                        fd.write("\t%s: %s_%s,\n" % (values[i], package, builtin_types[types[i]]))
                    else:
                        print("we shouldn't get here")
                
                fd.write("]\n\n")

                imported_types[full_type] = cddl_full_type
                
            except Exception as e:
                print(e)

    # Create Enum header file
    enum_file = os.getcwd() + "/bm_msg_types.h"
    with open(enum_file, 'w') as enum_fd:

        enum_fd.write("#ifndef BM_MSG_TYPES_H__\n#define BM_MSG_TYPES_H__\n\n")
        enum_fd.write("#include <stdint.h>\n#include <stdbool.h>\n#include <stddef.h>\n#include <string.h>\n\n")

        enum_fd.write("enum {\n")

        for i in range(len(enum_types)):
            enum_fd.write("\t%s,\n" % enum_types[i])
        
        enum_fd.write("};\n\n")
        enum_fd.write("#endif /* BM_MSG_TYPES_H__ */")

    return_string = ' '.join(str(x) for x in return_values)
    # Print to stdout for bash script to feed into next python script
    print(return_string)
    return

if __name__ == '__main__':
    cwd = os.getcwd()
    args = parse_args()

    abs_out_path = cwd + "/" + args.outdir
    abs_in_path = cwd + "/" + args.indir
    abs_outfile = abs_out_path + "/" + args.filename
    msg_files = []

    try:
        if not os.path.exists(abs_out_path):
            try:
                os.makedirs(abs_out_path)
            except OSError:
                if not os.path.exists(abs_out_path):
                    raise
        search_path = genmsg.command_line.includepath_to_dict(abs_in_path)

        # Refer to ROS Wiki for package naming
        if not genmsg.is_legal_resource_base_name(args.package):
            raise MsgGenerationException("\nERROR: package name '%s' is illegal and cannot be used in message generation.\nPlease see http://ros.org/wiki/Names" % (args.package))

        # Store .msg files in list
        for filename in os.listdir(abs_in_path):
            if filename.endswith('.msg'):
                msg_files.append(abs_in_path + "/" + filename)

    except genmsg.InvalidMsgSpec as e:
        print(e)
    except MsgGenerationException as e:
        print(e)
    except Exception as e:
        print(e)

    main(abs_out_path, abs_outfile, msg_files, args.package, search_path)